\documentclass[10pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[margin=0.6in]{geometry} 
\usepackage{enumitem} 
\usepackage{fancyhdr}
\usepackage{tikz} 

% --- Page Style Setup ---
\pagestyle{fancy}
\fancyhead{} 
\fancyfoot[R]{\thepage} 
\fancyfoot[C]{Sorting Algorithms Practice -- Solutions} 
\renewcommand{\headrulewidth}{0pt} 

% Set spacing: No paragraph skip and no paragraph indent
\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}

\begin{document}
\begin{center}
    {\small \textbf{IA Competitive Programming Club}} \\[6pt]
    {\Large Sorting Worksheet — Solutions} \\[8pt]
    {\small November 12, 2025}
\end{center}
\thispagestyle{fancy}
\vspace{0.3cm}

\hrule
\vspace{0.2cm}
\section*{Part I: Core Mechanics and Time Complexity}
\vspace{0.2cm}

\begin{enumerate}[label=\textbf{Q\arabic*.}, leftmargin=*, itemsep=0.8cm]

\item \textbf{Best-Case Efficiency}

\textbf{Answer:} \(\boxed{\text{Insertion Sort}}\) (and \(\boxed{\text{Bubble Sort}}\) \emph{if} it is implemented with the common optimization that stops when no swaps occur).

\textbf{Explanation:} Insertion Sort scans leftwards until the correct position for the current key is found; if the array is already sorted, each key requires only one comparison and no shifts, so the cost is linear \(\mathcal{O}(N)\). Bubble Sort can also run in \(\mathcal{O}(N)\) in the best case \emph{only} when it is implemented to detect that no swaps happened during a pass and then stop early. Selection Sort always looks through the remaining unsorted portion to find the minimum and therefore still does \(\Theta(N^2)\) comparisons even if the array is sorted.

\vspace{0.2cm}

\item \textbf{Counting Swaps}

\textbf{Answer:} \(\boxed{\text{Selection Sort}}\)

\textbf{Explanation:} Selection Sort performs exactly one swap per pass to place the found minimum into its final position (sometimes zero if implemented to avoid swapping an element with itself, but still at most \(N-1\) swaps). Thus the number of swaps is \(\mathcal{O}(N)\). By contrast, Bubble and Insertion can perform \(\Theta(N^2)\) swaps (or shifts) in the worst case.

\vspace{0.2cm}

\item \textbf{Trace: Selection Sort}

Initial array: \([9,\,1,\,5,\,2,\,4]\)

\begin{enumerate}[label=\alph*., leftmargin=1cm]
    \item \textbf{After 1st pass:} \(\boxed{[1,\,9,\,5,\,2,\,4]}\).  
    \textbf{Why:} The minimum of the whole array is \(1\); swap it with the element at index 0 (9).
    \item \textbf{After 2nd pass:} \(\boxed{[1,\,2,\,5,\,9,\,4]}\).  
    \textbf{Why:} On the second pass we search the subarray \([9,5,2,4]\); the minimum is \(2\) (original index 3), so swap it into position 1.
\end{enumerate}

\vspace{0.2cm}

\item \textbf{Big-\(\mathcal{O}\) Comparison}

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Algorithm} & \textbf{Best Case} & \textbf{Worst Case} \\
\hline
Bubble Sort & \(\mathcal{O}(N)\) \text{ (with early-stop)} & \(\mathcal{O}(N^2)\) \\
\hline
Insertion Sort & \(\mathcal{O}(N)\) & \(\mathcal{O}(N^2)\) \\
\hline
Selection Sort & \(\mathcal{O}(N^2)\) & \(\mathcal{O}(N^2)\) \\
\hline
\end{tabular}
\end{center}

\textbf{Explanation:} See answers above — Selection Sort always performs the same number of comparisons regardless of input order; Insertion (and optimized Bubble) can exploit existing order to become linear in the best case.

\end{enumerate}

\hrule
\vspace{0.3cm}
\section*{Part II: Visualization and Practice}
\vspace{0.2cm}

\subsection*{Problem 5: Insertion Sort Visualization}

Current state after Pass 2 (given): \([1,\,3,\,7,\,8,\,4]\).

\textbf{Task:} Insert the element `8` (the element at index 3) into the sorted prefix.

\textbf{Answer:} \(\boxed{[1,\,3,\,7,\,8,\,4]}\) — the array does not change when inserting `8`.

\textbf{Explanation:} The sorted portion before inserting `8` is \([1,3,7]\). The next element is `8`. Since `8` is greater than all elements in the sorted prefix, it remains in place; thus the array after Pass 3 remains \([1,3,7,8,4]\). (Only when the next element is smaller than some elements in the sorted prefix do we shift.)

\vspace{0.3cm}

\subsection*{Problem 6: Swap Counting (Bubble Sort)}

Input: \(A=[4,\,1,\,3,\,2]\).

\textbf{Trace (full passes):}

\begin{itemize}
    \item \textbf{After Pass 1:} compare (4,1) → swap \(\Rightarrow [1,4,3,2]\)  
    then (4,3) → swap \(\Rightarrow [1,3,4,2]\)  
    then (4,2) → swap \(\Rightarrow [1,3,2,4]\).  
    \(\Rightarrow\) \(\boxed{[1,\,3,\,2,\,4]}\).
    \item \textbf{After Pass 2:} (1,3) no swap → (3,2) swap \(\Rightarrow [1,2,3,4]\) → (3,4) no swap.  
    \(\Rightarrow\) \(\boxed{[1,\,2,\,3,\,4]}\).
\end{itemize}

\textbf{Total swaps to fully sort:} \(\boxed{4}\).

\textbf{Explanation:} We counted swaps during the comparisons above: three swaps in the first pass and one swap in the second pass, for a total of \(4\). After the second pass the array is fully sorted.

\vspace{0.3cm}

\subsection*{Problem 7: Modifying Sorting Direction}

\begin{enumerate}[label=(\alph*), leftmargin=1cm, itemsep=0.4cm]
\item \textbf{Insertion Sort:} Change the inner comparison so that elements are moved while they are \emph{smaller} than the key rather than \emph{larger}. Concretely, if the usual ascending inner loop uses:
\[
\texttt{while j >= 0 and A[j] > key:}
\]
for descending order use:
\[
\texttt{while j >= 0 and A[j] < key:}
\]
\textbf{Answer:} Replace `>` with `<` (i.e., move elements while \(A[j] < \text{key}\)).

\textbf{Why:} For descending order you want larger elements earlier, so shift smaller elements right until you find the correct (larger) spot for the key.

\item \textbf{Selection Sort:} Instead of searching for the minimum in the unsorted portion each pass, search for the \(\boxed{\text{maximum}}\) and swap it into the current position (or equivalently select the maximum and put it at the front).  

\textbf{Why:} Selection Sort builds the sorted portion by placing the chosen extremum each pass; choosing the maximum produces a descending final order.
\end{enumerate}

\vspace{0.3cm}

\subsection*{Problem 8: Efficiency on Sorted Input}

Array \(B=[1,2,\dots,10]\), so \(N=10\).

\begin{enumerate}[label=(\alph*), leftmargin=1cm, itemsep=0.4cm]
\item \textbf{Selection Sort comparisons:} Selection Sort always compares every unsorted element to find the minimum; the total number of comparisons is
\[
\sum_{i=0}^{N-2} (N-1-i) \;=\; \frac{N(N-1)}{2}.
\]
For \(N=10\): \(\displaystyle \frac{10\cdot 9}{2}=45\).  
\(\boxed{45\text{ comparisons}}\).

\item \textbf{Optimized Bubble Sort:} With the early-exit optimization, Bubble Sort will do one full pass (comparing each adjacent pair) and detect that no swaps occurred, then stop. A single pass compares \(N-1\) pairs. For \(N=10\): \(\boxed{1\text{ pass},\;9\text{ comparisons}}\).
\end{enumerate}

\textbf{Explanation:} Selection Sort's comparisons do not depend on input order; optimized Bubble Sort takes advantage of an already-sorted input to stop after the first pass.

\vspace{0.6cm}
\hrule
\vspace{0.2cm}
\end{document}
